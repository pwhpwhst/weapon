D:
cd D:\Users\Administrator\Desktop\project2018.3_2018.9\2018.3~2018.9\编译原理实验\微型编译器

F:
cd F:\codeWeaponStore\project2018.3_2018.9\2018.3~2018.9\编译原理实验\微型编译器

g++ -std=c++11 -c pwh.cpp
g++ -std=c++11 -c slr.cpp

g++ -std=c++11 -c symbols\Array.cpp
g++ -std=c++11 -c symbols\Env.cpp
g++ -std=c++11 -c symbols\Type.cpp

flex.exe  SLR\wordParser.l
gcc -c lex.yy.c
g++ -std=c++11 -c SLR\Lex_Word.cpp
g++ -std=c++11 -c SLR\Rule.cpp
g++ -std=c++11 -c SLR\Item.cpp
g++ -std=c++11 -c SLR\Node.cpp
g++ -std=c++11 -c SLR\Symbol.cpp


g++ -std=c++11 -c SDT_generator_generator.cpp
g++ -std=c++11 -o SDT_generator_generator SDT_generator_generator.o Rule.o
SDT_generator_generator.exe
g++ -std=c++11 -c SDT\SDT_generator.cpp
g++ -std=c++11 -c lexer\Token.cpp
g++ -std=c++11 -c lexer\Integer.cpp
g++ -std=c++11 -c lexer\Tag.cpp
g++ -std=c++11 -c lexer\Word.cpp
g++ -std=c++11 -c inter\Id.cpp



g++ -o pwh pwh.o slr.o Array.o Env.o Type.o lex.yy.o Lex_Word.o Rule.o Item.o Node.o Symbol.o SDT_generator.o Token.o Integer.o Tag.o Word.o Id.o


pwh.exe


切换编译体系（默认词法分析器用同一套）：
vi pwh.cpp
g++ -std=c++11 -c pwh.cpp
g++ -o pwh pwh.o slr.o Array.o Env.o Type.o lex.yy.o Lex_Word.o Rule.o Item.o Node.o Symbol.o SDT_generator.o Token.o Integer.o Tag.o Word.o Id.o
pwh.exe

==========================================

SDT_genertor

//生成ruleListing
	↓
new Rule(rule_str)


ele_begin : T		{$$=$0;}
T : B C			{$2.next=$0;$$=$2;}
B : 'simple-type-specifier'	{Type* type=new Type($0,Tag::BASIC,4);$$=type;}
C : 0	{$$=$$.next;}
C : '[' 'number' ']' C	{$4.next=$$.next;$$=new Array(atoi($2.c_str()),(Type*)$4);}	

==========================================


D:
cd D:\DaiMaWuQiKu\阿里云
git status -s 

git add 阿里云/新建文本文档.txt
git commit -m 版本提交
git push
git config --global credential.helper store
git pull

==========================================

 git rm -r --cached .
 git add .
 git commit -m 'update .gitignore'


===========================================


P_SDT_genertor sdt_genertor=SDT_Factory::instance.factory[top->node->get_rule_str()];
if(sdt_genertor!=nullptr){
	P_NodeValue p_nodeValue=sdt_genertor->handle(top,result_map,has_calculate_set);
	if(p_nodeValue!=nullptr){
		stack.push_back(p_nodeValue);
	}else{
		stack.pop_back();
	}
}
	↓
handle(const P_NodeValue &nodeValue,unordered_map<string,Token*> &result_map,set<string> &has_calculate_set)


===========================================


get_symbol_para
gen_attribute_name
gen_attribute_fun


fs<<"\tpublic: P_NodeValue handle(const P_NodeValue &nodeValue,unordered_map<string,Token*> &result_map,set<string> &has_calculate_set){"<<endl;
	↓
split(string_list,cmd_strs,is_any_of(";"));//string_list 此时保存着指令
	↓
split(string_list2,e21,is_any_of("="));
	↓
symbol_set.clear();
get_symbol_para(string_list2[0],symbol_set);	//模拟正则表达式的功能 $$.next S1 $$



===========================================

for(const auto &e:total_lex_word_list){
	lex_word_list.push_back(e);
	if(e->type=="';'"){
		//构造语法树
		lex_word_list.pop_back();
		Node *node_tree=syntax_analyze(ruleList,zero_terminator,forecast_list,convert_map,lex_word_list);
		#ifdef __PRINT_NODE_TREE
		
		if(node_tree!=nullptr){
//			printStack(node_tree);
			printStack2(node_tree);
		}
		
		
		
		if(node_tree!=nullptr){
			gen_middle_code(env,node_tree);
		}
		
				
		#endif
		lex_word_list.clear();
	}
}



gen_middle_code
============================================

inter/Id 没有实际应用

Symbol 没有实际应用



